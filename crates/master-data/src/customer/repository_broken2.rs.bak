use async_trait::async_trait;
use chrono::{DateTime, Utc};
use sqlx::{Executor, PgPool, Postgres, Row};
use std::collections::HashMap;
use uuid::Uuid;

use crate::customer::model::*;
use crate::error::{MasterDataError, Result};
use crate::types::*;
use erp_core::TenantContext;

/// Repository trait for customer operations
#[async_trait]
pub trait CustomerRepository: Send + Sync {
    /// Create a new customer
    async fn create_customer(&self, customer: &CreateCustomerRequest, created_by: Uuid) -> Result<Customer>;

    /// Get customer by ID
    async fn get_customer_by_id(&self, id: Uuid) -> Result<Option<Customer>>;

    /// Get customer by customer number
    async fn get_customer_by_number(&self, customer_number: &str) -> Result<Option<Customer>>;

    /// Update customer
    async fn update_customer(&self, id: Uuid, update: &UpdateCustomerRequest, modified_by: Uuid) -> Result<Customer>;

    /// Delete customer (soft delete)
    async fn delete_customer(&self, id: Uuid, deleted_by: Uuid) -> Result<()>;

    /// Search customers with advanced filtering
    async fn search_customers(&self, criteria: &CustomerSearchCriteria) -> Result<CustomerSearchResponse>;

    /// Get customer hierarchy (parent and children)
    async fn get_customer_hierarchy(&self, customer_id: Uuid) -> Result<Vec<Customer>>;

    /// Get customers by corporate group
    async fn get_customers_by_corporate_group(&self, group_id: Uuid) -> Result<Vec<Customer>>;

    /// Check if customer number is available
    async fn is_customer_number_available(&self, customer_number: &str) -> Result<bool>;

    /// Generate next customer number
    async fn generate_customer_number(&self, customer_type: &CustomerType) -> Result<String>;

    /// Update customer performance metrics
    async fn update_performance_metrics(&self, customer_id: Uuid, metrics: &CustomerPerformanceMetrics) -> Result<()>;

    /// Update customer behavioral data
    async fn update_behavioral_data(&self, customer_id: Uuid, data: &CustomerBehavioralData) -> Result<()>;

    /// Get customer addresses
    async fn get_customer_addresses(&self, customer_id: Uuid) -> Result<Vec<Address>>;

    /// Get customer contacts
    async fn get_customer_contacts(&self, customer_id: Uuid) -> Result<Vec<ContactInfo>>;

    /// Add address to customer
    async fn add_customer_address(&self, customer_id: Uuid, address: &CreateAddressRequest, created_by: Uuid) -> Result<Address>;

    /// Add contact to customer
    async fn add_customer_contact(&self, customer_id: Uuid, contact: &CreateContactRequest, created_by: Uuid) -> Result<ContactInfo>;

    /// Update address
    async fn update_address(&self, address_id: Uuid, address: &Address, modified_by: Uuid) -> Result<Address>;

    /// Update contact
    async fn update_contact(&self, contact_id: Uuid, contact: &ContactInfo, modified_by: Uuid) -> Result<ContactInfo>;

    /// Delete address
    async fn delete_address(&self, address_id: Uuid) -> Result<()>;

    /// Delete contact
    async fn delete_contact(&self, contact_id: Uuid) -> Result<()>;
}

/// PostgreSQL implementation of CustomerRepository
pub struct PostgresCustomerRepository {
    pool: PgPool,
    tenant_context: TenantContext,
}

impl PostgresCustomerRepository {
    pub fn new(pool: PgPool, tenant_context: TenantContext) -> Self {
        Self { pool, tenant_context }
    }

    /// Build customer from database row with optional related data
    async fn build_customer_from_row(&self, _row: &sqlx::postgres::PgRow, _include_related: bool) -> Result<Customer> {
        // TODO: Implement proper customer building from database row
        // For now, return a minimal customer to fix compilation
        use std::collections::HashMap;
        use crate::types::*;
        use uuid::Uuid;
        use chrono::Utc;

        Ok(Customer {
            id: Uuid::new_v4(),
            customer_number: "TEMP-001".to_string(),
            external_ids: HashMap::new(),
            legal_name: "Temporary Customer".to_string(),
            trade_names: vec![],
            customer_type: CustomerType::B2b,
            industry_classification: IndustryClassification::Other,
            business_size: BusinessSize::Medium,
            parent_customer_id: None,
            corporate_group_id: None,
            customer_hierarchy_level: 0,
            consolidation_group: None,
            lifecycle_stage: CustomerLifecycleStage::Prospect,
            status: EntityStatus::Active,
            credit_status: CreditStatus::Good,
            primary_address_id: None,
            billing_address_id: None,
            shipping_address_ids: vec![],
            addresses: vec![],
            primary_contact_id: None,
            contacts: vec![],
            tax_jurisdictions: vec![],
            tax_numbers: HashMap::new(),
            regulatory_classifications: vec![],
            compliance_status: ComplianceStatus::Compliant,
            kyc_status: KycStatus::Completed,
            aml_risk_rating: RiskRating::Low,
            financial_info: FinancialInfo::default(),
            price_group_id: None,
            discount_group_id: None,
            sales_representative_id: None,
            account_manager_id: None,
            customer_segments: vec![],
            acquisition_channel: None,
            customer_lifetime_value: None,
            churn_probability: None,
            performance_metrics: CustomerPerformanceMetrics::default(),
            behavioral_data: CustomerBehavioralData::default(),
            sync_info: SyncInfo::default(),
            communication_preferences: CommunicationPreferences::default(),
            tags: vec![],
            notes: None,
            custom_fields: HashMap::new(),
            contract_ids: vec![],
            audit: AuditFields {
                created_by: Uuid::new_v4(),
                created_at: Utc::now(),
                modified_by: Uuid::new_v4(),
                modified_at: Utc::now(),
                version: 1,
                is_deleted: false,
                deleted_at: None,
                deleted_by: None,
            },
        })
    }

    /// Get performance metrics for a customer
    async fn get_performance_metrics(&self, customer_id: Uuid) -> Result<Option<CustomerPerformanceMetrics>> {
            id: customer_id,
            customer_number: row.get("customer_number"),
            external_ids: row.get::<sqlx::types::Json<std::collections::HashMap<String, String>>, _>("external_ids").0,
            legal_name: row.get("legal_name"),
            trade_names: row.get("trade_names"),
            customer_type: row.get("customer_type"),
            industry_classification: row.get::<sqlx::types::Json<IndustryClassification>, _>("industry_classification").0,
            business_size: row.get("business_size"),
            parent_customer_id: row.get("parent_customer_id"),
            corporate_group_id: row.get("corporate_group_id"),
            customer_hierarchy_level: row.get::<i16, _>("customer_hierarchy_level") as u8,
            consolidation_group: row.get("consolidation_group"),
            lifecycle_stage: row.get("lifecycle_stage"),
            status: row.get("status"),
            credit_status: row.get("credit_status"),
            primary_address_id: row.get("primary_address_id"),
            billing_address_id: row.get("billing_address_id"),
            shipping_address_ids: row.get("shipping_address_ids"),
            addresses: Vec::new(),
            primary_contact_id: row.get("primary_contact_id"),
            contacts: Vec::new(),
            tax_jurisdictions: row.get::<sqlx::types::Json<Vec<TaxJurisdiction>>, _>("tax_jurisdictions").0,
            tax_numbers: row.get::<sqlx::types::Json<std::collections::HashMap<String, String>>, _>("tax_numbers").0,
            regulatory_classifications: row.get::<sqlx::types::Json<Vec<RegulatoryClassification>>, _>("regulatory_classifications").0,
            compliance_status: row.get("compliance_status"),
            kyc_status: row.get("kyc_status"),
            aml_risk_rating: row.get("aml_risk_rating"),
            financial_info: FinancialInfo {
                currency_code: row.get("currency_code"),
                credit_limit: row.get("credit_limit"),
                payment_terms: row.get::<Option<sqlx::types::Json<PaymentTerms>>, _>("payment_terms").map(|j| j.0),
                tax_exempt: row.get("tax_exempt"),
                tax_numbers: row.get::<sqlx::types::Json<std::collections::HashMap<String, String>>, _>("tax_numbers").0,
            },
            price_group_id: row.get("price_group_id"),
            discount_group_id: row.get("discount_group_id"),
            sales_representative_id: row.get("sales_representative_id"),
            account_manager_id: row.get("account_manager_id"),
            customer_segments: row.get::<sqlx::types::Json<Vec<CustomerSegment>>, _>("customer_segments").0,
            acquisition_channel: row.get("acquisition_channel"),
            customer_lifetime_value: row.get("customer_lifetime_value"),
            churn_probability: row.get("churn_probability"),
            performance_metrics: CustomerPerformanceMetrics::default(),
            behavioral_data: CustomerBehavioralData::default(),
            sync_info: SyncInfo {
                last_sync: row.get("last_sync"),
                sync_source: row.get("sync_source"),
                sync_version: row.get("sync_version"),
                sync_status: row.get("sync_status"),
                external_references: HashMap::new(),
            },
            audit: AuditFields {
                created_by: row.get("created_by"),
                created_at: row.get("created_at"),
                modified_by: row.get("modified_by"),
                modified_at: row.get("modified_at"),
                version: row.get("version"),
                is_deleted: row.get::<Option<bool>, _>("is_deleted").unwrap_or(false),
                deleted_at: row.get("deleted_at"),
                deleted_by: row.get("deleted_by"),
            },
        };

        if include_related {
            // Load addresses
            customer.addresses = self.get_customer_addresses(customer_id).await?;

            // Load contacts
            customer.contacts = self.get_customer_contacts(customer_id).await?;

            // Load performance metrics
            if let Some(metrics) = self.get_performance_metrics(customer_id).await? {
                customer.performance_metrics = metrics;
            }

            // Load behavioral data
            if let Some(behavioral) = self.get_behavioral_data(customer_id).await? {
                customer.behavioral_data = behavioral;
            }
        }

        Ok(customer)
    }

    /// Get performance metrics for a customer
    async fn get_performance_metrics(&self, customer_id: Uuid) -> Result<Option<CustomerPerformanceMetrics>> {
        let row = sqlx::query!(
            r#"
            SELECT
                total_revenue,
                average_order_value,
                total_orders,
                last_order_date,
                relationship_duration_days,
                satisfaction_score,
                net_promoter_score,
                last_contact_date,
                contact_frequency,
                response_rate,
                days_sales_outstanding,
                payment_reliability_score,
                support_ticket_count,
                last_calculated
            FROM customer_performance_metrics
            WHERE tenant_id = $1 AND customer_id = $2
            "#,
            self.tenant_context.tenant_id.0,
            customer_id
        )
        .fetch_optional(&self.pool)
        .await?;

        if let Some(row) = row {
            Ok(Some(CustomerPerformanceMetrics {
                total_revenue: row.total_revenue,
                average_order_value: row.average_order_value,
                total_orders: row.total_orders,
                last_order_date: row.last_order_date,
                relationship_duration_days: row.relationship_duration_days,
                satisfaction_score: row.satisfaction_score.map(|d| d.try_into().unwrap_or(0.0)),
                net_promoter_score: row.net_promoter_score.map(|i| i as i32),
                last_contact_date: row.last_contact_date,
                contact_frequency: row.contact_frequency.map(|d| d.try_into().unwrap_or(0.0)),
                response_rate: row.response_rate.map(|d| d.try_into().unwrap_or(0.0)),
                days_sales_outstanding: row.days_sales_outstanding.map(|d| d.try_into().unwrap_or(0.0)),
                payment_reliability_score: row.payment_reliability_score.map(|d| d.try_into().unwrap_or(0.0)),
                support_ticket_count: row.support_ticket_count,
                last_calculated: row.last_calculated,
            }))
        } else {
            Ok(None)
        }
    }

    /// Get behavioral data for a customer
    async fn get_behavioral_data(&self, customer_id: Uuid) -> Result<Option<CustomerBehavioralData>> {
        let row = sqlx::query!(
            r#"
            SELECT
                preferred_purchase_channels,
                seasonal_purchase_patterns,
                product_category_preferences,
                preferred_contact_times,
                channel_engagement_rates,
                website_engagement_score,
                mobile_app_usage,
                social_media_sentiment,
                propensity_to_buy,
                upsell_probability,
                cross_sell_probability,
                last_updated
            FROM customer_behavioral_data
            WHERE tenant_id = $1 AND customer_id = $2
            "#,
            self.tenant_context.tenant_id.0,
            customer_id
        )
        .fetch_optional(&self.pool)
        .await?;

        if let Some(row) = row {
            Ok(Some(CustomerBehavioralData {
                preferred_purchase_channels: serde_json::from_value(row.preferred_purchase_channels.unwrap_or_default())?,
                seasonal_purchase_patterns: serde_json::from_value(row.seasonal_purchase_patterns.unwrap_or_default())?,
                product_category_preferences: serde_json::from_value(row.product_category_preferences.unwrap_or_default())?,
                preferred_contact_times: serde_json::from_value(row.preferred_contact_times.unwrap_or_default())?,
                channel_engagement_rates: serde_json::from_value(row.channel_engagement_rates.unwrap_or_default())?,
                website_engagement_score: row.website_engagement_score.map(|d| d.try_into().unwrap_or(0.0)),
                mobile_app_usage: row.mobile_app_usage.map(|d| d.try_into().unwrap_or(0.0)),
                social_media_sentiment: row.social_media_sentiment.map(|d| d.try_into().unwrap_or(0.0)),
                propensity_to_buy: row.propensity_to_buy.map(|d| d.try_into().unwrap_or(0.0)),
                upsell_probability: row.upsell_probability.map(|d| d.try_into().unwrap_or(0.0)),
                cross_sell_probability: row.cross_sell_probability.map(|d| d.try_into().unwrap_or(0.0)),
                last_updated: row.last_updated,
            }))
        } else {
            Ok(None)
        }
    }
}

#[async_trait]
impl CustomerRepository for PostgresCustomerRepository {
    async fn create_customer(&self, request: &CreateCustomerRequest, created_by: Uuid) -> Result<Customer> {
        let mut tx = self.pool.begin().await?;

        // Generate customer number if not provided
        let customer_number = if let Some(ref number) = request.customer_number {
            // Validate provided customer number
            if !self.is_customer_number_available(number).await? {
                return Err(MasterDataError::DuplicateCustomerNumber {
                    number: number.clone(),
                });
            }
            number.clone()
        } else {
            self.generate_customer_number(&request.customer_type).await?
        };

        let customer_id = Uuid::new_v4();
        let now = Utc::now();

        // Insert customer
        sqlx::query!(
            r#"
            INSERT INTO customers (
                id, tenant_id, customer_number, legal_name, trade_names,
                customer_type, industry_classification, business_size,
                parent_customer_id, corporate_group_id,
                lifecycle_stage, status, credit_status,
                tax_jurisdictions, tax_numbers,
                currency_code, credit_limit, payment_terms, tax_exempt,
                sales_representative_id, account_manager_id, acquisition_channel,
                external_ids, master_data_source, external_id, sync_status,
                created_by, created_at, modified_by, modified_at
            ) VALUES (
                $1, $2, $3, $4, $5,
                $6::customer_type, $7::industry_classification, $8::business_size,
                $9, $10,
                $11::customer_lifecycle_stage, $12::entity_status, $13::credit_status,
                $14, $15,
                $16, $17, $18, $19,
                $20, $21, $22::acquisition_channel,
                $23, $24::data_source, $25, $26,
                $27, $28, $29, $30
            )
            "#,
            customer_id,
            self.tenant_context.tenant_id.0,
            customer_number,
            request.legal_name,
            request.trade_names.as_ref().unwrap_or(&Vec::new()) as &Vec<String>,
            request.customer_type as CustomerType,
            sqlx::types::Json(request.industry_classification.as_ref().unwrap_or(&IndustryClassification::Other)),
            request.business_size as Option<BusinessSize>,
            request.parent_customer_id,
            request.corporate_group_id,
            request.lifecycle_stage.unwrap_or(CustomerLifecycleStage::Prospect) as CustomerLifecycleStage,
            request.status.unwrap_or(EntityStatus::Active) as EntityStatus,
            request.credit_status.unwrap_or(CreditStatus::Good) as CreditStatus,
            sqlx::types::Json(request.tax_jurisdictions.as_ref().unwrap_or(&Vec::new())),
            sqlx::types::Json(request.tax_numbers.as_ref().unwrap_or(&std::collections::HashMap::new())),
            request.financial_info.as_ref().map(|f| f.currency_code.as_str()).unwrap_or("USD"),
            request.financial_info.as_ref().and_then(|f| f.credit_limit),
            sqlx::types::Json(request.financial_info.as_ref().map(|f| f.payment_terms.as_ref().unwrap_or(&PaymentTerms::default())).unwrap_or(&PaymentTerms::default())),
            request.financial_info.as_ref().map(|f| f.tax_exempt.unwrap_or(false)).unwrap_or(false),
            request.sales_representative_id,
            request.account_manager_id,
            request.acquisition_channel as Option<AcquisitionChannel>,
            sqlx::types::Json(request.external_ids.as_ref().unwrap_or(&std::collections::HashMap::new())),
            request.sync_info.as_ref().and_then(|s| s.sync_source.as_ref()).map(|_| DataSource::Manual).unwrap_or(DataSource::Manual) as DataSource,
            request.sync_info.as_ref().and_then(|s| s.external_references.get("external_id")).map(|s| s.as_str()),
            request.sync_info.as_ref().map(|s| s.sync_status).unwrap_or(SyncStatus::Success) as SyncStatus,
            created_by,
            now,
            created_by,
            now
        )
        .execute(&mut *tx)
        .await?;

        // Create addresses if provided
        if let Some(ref addresses) = request.addresses {
            for address_req in addresses {
                self.create_address_internal(&mut tx, customer_id, "customer", address_req, created_by).await?;
            }
        }

        // Create contacts if provided
        if let Some(ref contacts) = request.contacts {
            for contact_req in contacts {
                self.create_contact_internal(&mut tx, customer_id, "customer", contact_req, created_by).await?;
            }
        }

        tx.commit().await?;

        // Fetch and return the created customer
        self.get_customer_by_id(customer_id).await?
            .ok_or_else(|| MasterDataError::Internal {
                message: "Failed to retrieve created customer".to_string(),
            })
    }

    async fn get_customer_by_id(&self, id: Uuid) -> Result<Option<Customer>> {
        let row = sqlx::query(
            r#"
            SELECT
                id, customer_number, external_ids, legal_name, trade_names,
                customer_type, industry_classification, business_size,
                parent_customer_id, corporate_group_id, customer_hierarchy_level,
                consolidation_group, lifecycle_stage,
                status, credit_status,
                primary_address_id, billing_address_id, shipping_address_ids,
                primary_contact_id, tax_jurisdictions, tax_numbers,
                regulatory_classifications, compliance_status,
                kyc_status, aml_risk_rating,
                currency_code, credit_limit, payment_terms, tax_exempt,
                price_group_id, discount_group_id, sales_representative_id,
                account_manager_id, customer_segments, acquisition_channel,
                customer_lifetime_value, churn_probability,
                master_data_source,
                external_id, sync_status,
                last_sync_timestamp, sync_errors,
                created_by, created_at, modified_by, modified_at, version
            FROM customers
            WHERE tenant_id = $1 AND id = $2 AND status != 'deleted'
            "#
        )
        .bind(self.tenant_context.tenant_id.0)
        .bind(id)
        .fetch_optional(&self.pool)
        .await?;

        if let Some(row) = row {
            Ok(Some(self.build_customer_from_row(&row, true).await?))
        } else {
            Ok(None)
        }
    }

    async fn get_customer_by_number(&self, customer_number: &str) -> Result<Option<Customer>> {
        let row = sqlx::query(
            r#"
            SELECT
                id, customer_number, external_ids, legal_name, trade_names,
                customer_type, industry_classification, business_size,
                parent_customer_id, corporate_group_id, customer_hierarchy_level,
                consolidation_group, lifecycle_stage,
                status, credit_status,
                primary_address_id, billing_address_id, shipping_address_ids,
                primary_contact_id, tax_jurisdictions, tax_numbers,
                regulatory_classifications, compliance_status,
                kyc_status, aml_risk_rating,
                currency_code, credit_limit, payment_terms, tax_exempt,
                price_group_id, discount_group_id, sales_representative_id,
                account_manager_id, customer_segments, acquisition_channel,
                customer_lifetime_value, churn_probability,
                master_data_source,
                external_id, sync_status,
                last_sync_timestamp, sync_errors,
                created_by, created_at, modified_by, modified_at, version
            FROM customers
            WHERE tenant_id = $1 AND customer_number = $2 AND status != 'deleted'
            "#
        )
        .bind(self.tenant_context.tenant_id.0)
        .bind(customer_number)
        .fetch_optional(&self.pool)
        .await?;

        if let Some(row) = row {
            Ok(Some(self.build_customer_from_row(&row, true).await?))
        } else {
            Ok(None)
        }
    }

    async fn update_customer(&self, id: Uuid, update: &UpdateCustomerRequest, modified_by: Uuid) -> Result<Customer> {
        let mut tx = self.pool.begin().await?;

        // First, get the current customer to check version for optimistic locking
        let current = sqlx::query!(
            "SELECT version FROM customers WHERE tenant_id = $1 AND id = $2 AND status != 'deleted'",
            self.tenant_context.tenant_id.0,
            id
        )
        .fetch_optional(&mut *tx)
        .await?;

        let current = current.ok_or_else(|| MasterDataError::CustomerNotFound { id: id.to_string() })?;

        // Check version for optimistic locking
        if current.version != update.version {
            return Err(MasterDataError::SynchronizationConflict {
                entity_type: "customer".to_string(),
                entity_id: id.to_string(),
                local_version: update.version,
                remote_version: current.version,
            });
        }

        // Build dynamic UPDATE query based on provided fields
        let mut query_parts = Vec::new();
        let mut param_count = 3; // Starting after tenant_id, id, version check

        if update.legal_name.is_some() {
            query_parts.push(format!("legal_name = ${}", param_count));
            param_count += 1;
        }

        if update.trade_names.is_some() {
            query_parts.push(format!("trade_names = ${}", param_count));
            param_count += 1;
        }

        if update.customer_type.is_some() {
            query_parts.push(format!("customer_type = ${}::customer_type", param_count));
            param_count += 1;
        }

        if update.industry_classification.is_some() {
            query_parts.push(format!("industry_classification = ${}::industry_classification", param_count));
            param_count += 1;
        }

        if update.business_size.is_some() {
            query_parts.push(format!("business_size = ${}::business_size", param_count));
            param_count += 1;
        }

        if update.parent_customer_id.is_some() {
            query_parts.push(format!("parent_customer_id = ${}", param_count));
            param_count += 1;
        }

        if update.corporate_group_id.is_some() {
            query_parts.push(format!("corporate_group_id = ${}", param_count));
            param_count += 1;
        }

        if update.lifecycle_stage.is_some() {
            query_parts.push(format!("lifecycle_stage = ${}::customer_lifecycle_stage", param_count));
            param_count += 1;
        }

        if update.status.is_some() {
            query_parts.push(format!("status = ${}", param_count));
            param_count += 1;
        }

        if update.credit_status.is_some() {
            query_parts.push(format!("credit_status = ${}", param_count));
            param_count += 1;
        }

        if update.tax_numbers.is_some() {
            query_parts.push(format!("tax_numbers = ${}", param_count));
            param_count += 1;
        }

        if let Some(ref financial_info) = update.financial_info {
            if financial_info.currency_code.is_some() {
                query_parts.push(format!("currency_code = ${}", param_count));
                param_count += 1;
            }
            if financial_info.credit_limit.is_some() {
                query_parts.push(format!("credit_limit = ${}", param_count));
                param_count += 1;
            }
            if financial_info.payment_terms.is_some() {
                query_parts.push(format!("payment_terms = ${}", param_count));
                param_count += 1;
            }
            if financial_info.tax_exempt.is_some() {
                query_parts.push(format!("tax_exempt = ${}", param_count));
                param_count += 1;
            }
        }

        if update.sales_representative_id.is_some() {
            query_parts.push(format!("sales_representative_id = ${}", param_count));
            param_count += 1;
        }

        if update.account_manager_id.is_some() {
            query_parts.push(format!("account_manager_id = ${}", param_count));
            param_count += 1;
        }

        if update.external_ids.is_some() {
            query_parts.push(format!("external_ids = ${}", param_count));
            param_count += 1;
        }

        if let Some(ref sync_info) = update.sync_info {
            query_parts.push(format!("sync_status = ${}", param_count));
            param_count += 1;
            query_parts.push(format!("last_sync_timestamp = ${}", param_count));
            param_count += 1;
        }

        // Always update modified_by, modified_at, and version
        query_parts.push(format!("modified_by = ${}", param_count));
        param_count += 1;
        query_parts.push(format!("modified_at = now()"));
        query_parts.push(format!("version = version + 1"));

        if query_parts.is_empty() {
            // No fields to update, just return current customer
            tx.commit().await?;
            return self.get_customer_by_id(id).await?
                .ok_or_else(|| MasterDataError::CustomerNotFound { id: id.to_string() });
        }

        let update_query = format!(
            "UPDATE customers SET {} WHERE tenant_id = $1 AND id = $2 AND version = $3",
            query_parts.join(", ")
        );

        // Execute the dynamic update query
        // Note: This is a simplified version. In a real implementation, you'd use a query builder
        // or prepared statements for better performance and security
        let mut query = sqlx::query(&update_query)
            .bind(self.tenant_context.tenant_id.0)
            .bind(id)
            .bind(update.version);

        // Bind parameters in the same order as query_parts
        if let Some(ref legal_name) = update.legal_name {
            query = query.bind(legal_name);
        }

        if let Some(ref trade_names) = update.trade_names {
            query = query.bind(trade_names);
        }

        if let Some(ref customer_type) = update.customer_type {
            query = query.bind(customer_type);
        }

        if let Some(ref industry_classification) = update.industry_classification {
            query = query.bind(sqlx::types::Json(industry_classification));
        }

        if let Some(ref business_size) = update.business_size {
            query = query.bind(business_size);
        }

        if let Some(ref parent_customer_id) = update.parent_customer_id {
            query = query.bind(parent_customer_id);
        }

        if let Some(ref corporate_group_id) = update.corporate_group_id {
            query = query.bind(corporate_group_id);
        }

        if let Some(ref lifecycle_stage) = update.lifecycle_stage {
            query = query.bind(lifecycle_stage);
        }

        if let Some(ref status) = update.status {
            query = query.bind(status);
        }

        if let Some(ref credit_status) = update.credit_status {
            query = query.bind(credit_status);
        }

        if let Some(ref tax_numbers) = update.tax_numbers {
            query = query.bind(sqlx::types::Json(tax_numbers));
        }

        if let Some(ref financial_info) = update.financial_info {
            if let Some(ref currency_code) = financial_info.currency_code {
                query = query.bind(currency_code);
            }
            if let Some(ref credit_limit) = financial_info.credit_limit {
                query = query.bind(credit_limit);
            }
            if let Some(ref payment_terms) = financial_info.payment_terms {
                query = query.bind(sqlx::types::Json(payment_terms));
            }
            if let Some(ref tax_exempt) = financial_info.tax_exempt {
                query = query.bind(tax_exempt);
            }
        }

        if let Some(ref sales_rep_id) = update.sales_representative_id {
            query = query.bind(sales_rep_id);
        }

        if let Some(ref account_mgr_id) = update.account_manager_id {
            query = query.bind(account_mgr_id);
        }

        if let Some(ref external_ids) = update.external_ids {
            query = query.bind(sqlx::types::Json(external_ids));
        }

        if let Some(ref sync_info) = update.sync_info {
            query = query.bind(sync_info.sync_status);
            query = query.bind(sync_info.last_sync);
        }

        // Bind modified_by
        query = query.bind(modified_by);

        let rows_affected = query.execute(&mut *tx).await?.rows_affected();

        if rows_affected == 0 {
            return Err(MasterDataError::CustomerNotFound { id: id.to_string() });
        }

        tx.commit().await?;

        // Return the updated customer
        self.get_customer_by_id(id).await?
            .ok_or_else(|| MasterDataError::CustomerNotFound { id: id.to_string() })
    }

    async fn delete_customer(&self, id: Uuid, deleted_by: Uuid) -> Result<()> {
        let rows_affected = sqlx::query!(
            r#"
            UPDATE customers
            SET status = 'deleted', modified_by = $1, modified_at = now(), version = version + 1
            WHERE tenant_id = $2 AND id = $3 AND status != 'deleted'
            "#,
            deleted_by,
            self.tenant_context.tenant_id.0,
            id
        )
        .execute(&self.pool)
        .await?
        .rows_affected();

        if rows_affected == 0 {
            return Err(MasterDataError::CustomerNotFound { id: id.to_string() });
        }

        Ok(())
    }

    async fn search_customers(&self, criteria: &CustomerSearchCriteria) -> Result<CustomerSearchResponse> {
        let page = criteria.page.unwrap_or(1);
        let page_size = criteria.page_size.unwrap_or(50).min(1000); // Max 1000 per page
        let offset = (page - 1) * page_size;

        // Build dynamic WHERE clause
        let mut where_conditions = vec!["tenant_id = $1".to_string(), "status != 'deleted'".to_string()];
        let mut param_count = 2;

        // Text search across multiple fields
        if let Some(ref search_term) = criteria.search_term {
            if !search_term.trim().is_empty() {
                where_conditions.push(format!(
                    "(to_tsvector('english', coalesce(legal_name, '') || ' ' || coalesce(customer_number, '') || ' ' || coalesce(array_to_string(trade_names, ' '), '')) @@ plainto_tsquery('english', ${}))",
                    param_count
                ));
                param_count += 1;
            }
        }

        // Customer numbers filter
        if let Some(ref customer_numbers) = criteria.customer_numbers {
            if !customer_numbers.is_empty() {
                where_conditions.push(format!("customer_number = ANY(${})", param_count));
                param_count += 1;
            }
        }

        // Customer types filter
        if let Some(ref customer_types) = criteria.customer_types {
            if !customer_types.is_empty() {
                where_conditions.push(format!("customer_type = ANY(${}::customer_type[])", param_count));
                param_count += 1;
            }
        }

        // Status filter
        if let Some(ref statuses) = criteria.statuses {
            if !statuses.is_empty() {
                where_conditions.push(format!("status = ANY(${})", param_count));
                param_count += 1;
            }
        }

        // Lifecycle stages filter
        if let Some(ref lifecycle_stages) = criteria.lifecycle_stages {
            if !lifecycle_stages.is_empty() {
                where_conditions.push(format!("lifecycle_stage = ANY(${}::customer_lifecycle_stage[])", param_count));
                param_count += 1;
            }
        }

        // Hierarchy filters
        if let Some(parent_id) = criteria.parent_customer_id {
            where_conditions.push(format!("parent_customer_id = ${}", param_count));
            param_count += 1;
        }

        if let Some(group_id) = criteria.corporate_group_id {
            where_conditions.push(format!("corporate_group_id = ${}", param_count));
            param_count += 1;
        }

        if let Some(level) = criteria.hierarchy_level {
            where_conditions.push(format!("customer_hierarchy_level = ${}", param_count));
            param_count += 1;
        }

        // Geographic filters
        if let Some(ref country_codes) = criteria.country_codes {
            if !country_codes.is_empty() {
                where_conditions.push(format!(
                    "id IN (SELECT DISTINCT entity_id FROM addresses WHERE tenant_id = $1 AND entity_type = 'customer' AND country_code = ANY(${})) OR primary_address_id IN (SELECT id FROM addresses WHERE tenant_id = $1 AND country_code = ANY(${})) OR billing_address_id IN (SELECT id FROM addresses WHERE tenant_id = $1 AND country_code = ANY({}))",
                    param_count, param_count, param_count
                ));
                param_count += 1;
            }
        }

        if let Some(ref cities) = criteria.cities {
            if !cities.is_empty() {
                where_conditions.push(format!(
                    "id IN (SELECT DISTINCT entity_id FROM addresses WHERE tenant_id = $1 AND entity_type = 'customer' AND city = ANY(${}))",
                    param_count
                ));
                param_count += 1;
            }
        }

        // Commercial filters
        if let Some(ref sales_rep_ids) = criteria.sales_representative_ids {
            if !sales_rep_ids.is_empty() {
                where_conditions.push(format!("sales_representative_id = ANY(${})", param_count));
                param_count += 1;
            }
        }

        if let Some(ref account_mgr_ids) = criteria.account_manager_ids {
            if !account_mgr_ids.is_empty() {
                where_conditions.push(format!("account_manager_id = ANY(${})", param_count));
                param_count += 1;
            }
        }

        if let Some(ref credit_statuses) = criteria.credit_statuses {
            if !credit_statuses.is_empty() {
                where_conditions.push(format!("credit_status = ANY(${})", param_count));
                param_count += 1;
            }
        }

        // Financial filters
        if let Some(min_credit) = criteria.min_credit_limit {
            where_conditions.push(format!("credit_limit >= ${}", param_count));
            param_count += 1;
        }

        if let Some(max_credit) = criteria.max_credit_limit {
            where_conditions.push(format!("credit_limit <= ${}", param_count));
            param_count += 1;
        }

        if let Some(min_clv) = criteria.min_customer_lifetime_value {
            where_conditions.push(format!("customer_lifetime_value >= ${}", param_count));
            param_count += 1;
        }

        if let Some(max_clv) = criteria.max_customer_lifetime_value {
            where_conditions.push(format!("customer_lifetime_value <= ${}", param_count));
            param_count += 1;
        }

        // Date filters
        if let Some(created_after) = criteria.created_after {
            where_conditions.push(format!("created_at >= ${}", param_count));
            param_count += 1;
        }

        if let Some(created_before) = criteria.created_before {
            where_conditions.push(format!("created_at <= ${}", param_count));
            param_count += 1;
        }

        if let Some(modified_after) = criteria.modified_after {
            where_conditions.push(format!("modified_at >= ${}", param_count));
            param_count += 1;
        }

        if let Some(modified_before) = criteria.modified_before {
            where_conditions.push(format!("modified_at <= ${}", param_count));
            param_count += 1;
        }

        // Analytics filters
        if let Some(min_churn) = criteria.min_churn_probability {
            where_conditions.push(format!("churn_probability >= ${}", param_count));
            param_count += 1;
        }

        if let Some(max_churn) = criteria.max_churn_probability {
            where_conditions.push(format!("churn_probability <= ${}", param_count));
            param_count += 1;
        }

        if let Some(ref risk_ratings) = criteria.risk_ratings {
            if !risk_ratings.is_empty() {
                where_conditions.push(format!("aml_risk_rating = ANY(${})", param_count));
                param_count += 1;
            }
        }

        // Build ORDER BY clause
        let order_by = match criteria.sort_by.as_ref().unwrap_or(&CustomerSortField::CustomerNumber) {
            CustomerSortField::CustomerNumber => "customer_number",
            CustomerSortField::LegalName => "legal_name",
            CustomerSortField::CreatedAt => "created_at",
            CustomerSortField::ModifiedAt => "modified_at",
            CustomerSortField::LastOrderDate => "COALESCE((performance_metrics->>'last_order_date')::timestamptz, '1900-01-01'::timestamptz)",
            CustomerSortField::CustomerLifetimeValue => "COALESCE(customer_lifetime_value, 0)",
            CustomerSortField::ChurnProbability => "COALESCE(churn_probability, 0)",
            CustomerSortField::TotalRevenue => "COALESCE((performance_metrics->>'total_revenue')::decimal, 0)",
        };

        let sort_direction = match criteria.sort_order.as_ref().unwrap_or(&SortOrder::Asc) {
            SortOrder::Asc => "ASC",
            SortOrder::Desc => "DESC",
        };

        // Build the full query
        let where_clause = where_conditions.join(" AND ");
        let base_query = format!(
            r#"
            SELECT
                id, customer_number, external_ids, legal_name, trade_names,
                customer_type as "customer_type: CustomerType",
                industry_classification, business_size as "business_size: BusinessSize",
                parent_customer_id, corporate_group_id, customer_hierarchy_level,
                consolidation_group, lifecycle_stage as "lifecycle_stage: CustomerLifecycleStage",
                status as "status: EntityStatus", credit_status as "credit_status: CreditStatus",
                primary_address_id, billing_address_id, shipping_address_ids,
                primary_contact_id, tax_jurisdictions, tax_numbers,
                regulatory_classifications, compliance_status as "compliance_status: ComplianceStatus",
                kyc_status as "kyc_status: KycStatus", aml_risk_rating as "aml_risk_rating: RiskRating",
                currency_code, credit_limit, payment_terms, tax_exempt,
                price_group_id, discount_group_id, sales_representative_id,
                account_manager_id, customer_segments, acquisition_channel as "acquisition_channel: AcquisitionChannel",
                customer_lifetime_value, churn_probability,
                master_data_source as "master_data_source: DataSource",
                external_id, sync_status as "sync_status: SyncStatus",
                last_sync_timestamp, sync_errors,
                created_by, created_at, modified_by, modified_at, version
            FROM customers
            WHERE {}
            ORDER BY {} {}
            LIMIT ${} OFFSET ${}
            "#,
            where_clause,
            order_by,
            sort_direction,
            param_count,
            param_count + 1
        );

        // Get total count for pagination
        let count_query = format!(
            "SELECT COUNT(*) as total FROM customers WHERE {}",
            where_clause
        );

        // Execute count query first
        let mut count_query_obj = sqlx::query_scalar(&count_query)
            .bind(self.tenant_context.tenant_id.0);

        // Bind the same parameters as the main query (except LIMIT/OFFSET)
        // TODO: Extract this into a generic parameter binding function
        if let Some(ref search_term) = criteria.search_term {
            if !search_term.trim().is_empty() {
                count_query_obj = count_query_obj.bind(search_term);
            }
        }
        if let Some(ref customer_numbers) = criteria.customer_numbers {
            if !customer_numbers.is_empty() {
                count_query_obj = count_query_obj.bind(customer_numbers);
            }
        }

        let total_count: i64 = count_query_obj.fetch_one(&self.pool).await?;

        // Execute main query
        let mut main_query = sqlx::query(&base_query)
            .bind(self.tenant_context.tenant_id.0);

        // Bind parameters
        main_query = self.bind_search_parameters(main_query, criteria, true)?;

        // Bind LIMIT and OFFSET
        main_query = main_query.bind(page_size as i64).bind(offset as i64);

        let rows = main_query.fetch_all(&self.pool).await?;

        // Convert rows to customers
        let mut customers = Vec::new();
        for row in rows {
            let include_related = criteria.include_addresses.unwrap_or(false)
                || criteria.include_contacts.unwrap_or(false)
                || criteria.include_performance_metrics.unwrap_or(false)
                || criteria.include_behavioral_data.unwrap_or(false);

            customers.push(self.build_customer_from_row(&row, include_related).await?);
        }

        let total_pages = ((total_count as u64 + page_size as u64 - 1) / page_size as u64) as u32;

        Ok(CustomerSearchResponse {
            customers,
            total_count: total_count as u64,
            page,
            page_size,
            total_pages,
        })
    }

    async fn get_customer_hierarchy(&self, customer_id: Uuid) -> Result<Vec<Customer>> {
        // Recursive query to get the full hierarchy tree (parent and all children)
        let rows = sqlx::query!(
            r#"
            WITH RECURSIVE customer_hierarchy AS (
                -- Base case: get the specified customer
                SELECT
                    id, customer_number, external_ids, legal_name, trade_names,
                    customer_type as "customer_type: CustomerType",
                    industry_classification, business_size as "business_size: BusinessSize",
                    parent_customer_id, corporate_group_id, customer_hierarchy_level,
                    consolidation_group, lifecycle_stage as "lifecycle_stage: CustomerLifecycleStage",
                    status as "status: EntityStatus", credit_status as "credit_status: CreditStatus",
                    primary_address_id, billing_address_id, shipping_address_ids,
                    primary_contact_id, tax_jurisdictions, tax_numbers,
                    regulatory_classifications, compliance_status as "compliance_status: ComplianceStatus",
                    kyc_status as "kyc_status: KycStatus", aml_risk_rating as "aml_risk_rating: RiskRating",
                    currency_code, credit_limit, payment_terms, tax_exempt,
                    price_group_id, discount_group_id, sales_representative_id,
                    account_manager_id, customer_segments, acquisition_channel as "acquisition_channel: AcquisitionChannel",
                    customer_lifetime_value, churn_probability,
                    master_data_source as "master_data_source: DataSource",
                    external_id, sync_status as "sync_status: SyncStatus",
                    last_sync_timestamp, sync_errors,
                    created_by, created_at, modified_by, modified_at, version,
                    0 as hierarchy_distance -- Distance from the root customer
                FROM customers
                WHERE tenant_id = $1 AND id = $2 AND status != 'deleted'

                UNION ALL

                -- Recursive case: get all children
                SELECT
                    c.id, c.customer_number, c.external_ids, c.legal_name, c.trade_names,
                    c.customer_type as "customer_type: CustomerType",
                    c.industry_classification, c.business_size as "business_size: BusinessSize",
                    c.parent_customer_id, c.corporate_group_id, c.customer_hierarchy_level,
                    c.consolidation_group, c.lifecycle_stage as "lifecycle_stage: CustomerLifecycleStage",
                    c.status as "status: EntityStatus", c.credit_status as "credit_status: CreditStatus",
                    c.primary_address_id, c.billing_address_id, c.shipping_address_ids,
                    c.primary_contact_id, c.tax_jurisdictions, c.tax_numbers,
                    c.regulatory_classifications, c.compliance_status as "compliance_status: ComplianceStatus",
                    c.kyc_status as "kyc_status: KycStatus", c.aml_risk_rating as "aml_risk_rating: RiskRating",
                    c.currency_code, c.credit_limit, c.payment_terms, c.tax_exempt,
                    c.price_group_id, c.discount_group_id, c.sales_representative_id,
                    c.account_manager_id, c.customer_segments, c.acquisition_channel as "acquisition_channel: AcquisitionChannel",
                    c.customer_lifetime_value, c.churn_probability,
                    c.master_data_source as "master_data_source: DataSource",
                    c.external_id, c.sync_status as "sync_status: SyncStatus",
                    c.last_sync_timestamp, c.sync_errors,
                    c.created_by, c.created_at, c.modified_by, c.modified_at, c.version,
                    ch.hierarchy_distance + 1
                FROM customers c
                JOIN customer_hierarchy ch ON c.parent_customer_id = ch.id
                WHERE c.tenant_id = $1 AND c.status != 'deleted'
            )

            -- Also get parent hierarchy (up to root)
            , parent_hierarchy AS (
                SELECT
                    id, customer_number, external_ids, legal_name, trade_names,
                    customer_type as "customer_type: CustomerType",
                    industry_classification, business_size as "business_size: BusinessSize",
                    parent_customer_id, corporate_group_id, customer_hierarchy_level,
                    consolidation_group, lifecycle_stage as "lifecycle_stage: CustomerLifecycleStage",
                    status as "status: EntityStatus", credit_status as "credit_status: CreditStatus",
                    primary_address_id, billing_address_id, shipping_address_ids,
                    primary_contact_id, tax_jurisdictions, tax_numbers,
                    regulatory_classifications, compliance_status as "compliance_status: ComplianceStatus",
                    kyc_status as "kyc_status: KycStatus", aml_risk_rating as "aml_risk_rating: RiskRating",
                    currency_code, credit_limit, payment_terms, tax_exempt,
                    price_group_id, discount_group_id, sales_representative_id,
                    account_manager_id, customer_segments, acquisition_channel as "acquisition_channel: AcquisitionChannel",
                    customer_lifetime_value, churn_probability,
                    master_data_source as "master_data_source: DataSource",
                    external_id, sync_status as "sync_status: SyncStatus",
                    last_sync_timestamp, sync_errors,
                    created_by, created_at, modified_by, modified_at, version,
                    -1 as hierarchy_distance -- Negative distance for parents
                FROM customers
                WHERE tenant_id = $1 AND id = (
                    SELECT parent_customer_id FROM customers
                    WHERE tenant_id = $1 AND id = $2 AND parent_customer_id IS NOT NULL
                ) AND status != 'deleted'

                UNION ALL

                SELECT
                    c.id, c.customer_number, c.external_ids, c.legal_name, c.trade_names,
                    c.customer_type as "customer_type: CustomerType",
                    c.industry_classification, c.business_size as "business_size: BusinessSize",
                    c.parent_customer_id, c.corporate_group_id, c.customer_hierarchy_level,
                    c.consolidation_group, c.lifecycle_stage as "lifecycle_stage: CustomerLifecycleStage",
                    c.status as "status: EntityStatus", c.credit_status as "credit_status: CreditStatus",
                    c.primary_address_id, c.billing_address_id, c.shipping_address_ids,
                    c.primary_contact_id, c.tax_jurisdictions, c.tax_numbers,
                    c.regulatory_classifications, c.compliance_status as "compliance_status: ComplianceStatus",
                    c.kyc_status as "kyc_status: KycStatus", c.aml_risk_rating as "aml_risk_rating: RiskRating",
                    c.currency_code, c.credit_limit, c.payment_terms, c.tax_exempt,
                    c.price_group_id, c.discount_group_id, c.sales_representative_id,
                    c.account_manager_id, c.customer_segments, c.acquisition_channel as "acquisition_channel: AcquisitionChannel",
                    c.customer_lifetime_value, c.churn_probability,
                    c.master_data_source as "master_data_source: DataSource",
                    c.external_id, c.sync_status as "sync_status: SyncStatus",
                    c.last_sync_timestamp, c.sync_errors,
                    c.created_by, c.created_at, c.modified_by, c.modified_at, c.version,
                    ph.hierarchy_distance - 1
                FROM customers c
                JOIN parent_hierarchy ph ON c.id = ph.parent_customer_id
                WHERE c.tenant_id = $1 AND c.status != 'deleted'
            )

            -- Combine both hierarchies
            SELECT * FROM customer_hierarchy
            UNION ALL
            SELECT * FROM parent_hierarchy
            ORDER BY hierarchy_distance, customer_hierarchy_level, legal_name
            "#,
            self.tenant_context.tenant_id.0,
            customer_id
        )
        .fetch_all(&self.pool)
        .await?;

        let mut customers = Vec::new();
        for row in rows {
            customers.push(self.build_customer_from_row(&row, false).await?);
        }

        Ok(customers)
    }

    async fn get_customers_by_corporate_group(&self, group_id: Uuid) -> Result<Vec<Customer>> {
        let rows = sqlx::query!(
            r#"
            SELECT
                id, customer_number, external_ids, legal_name, trade_names,
                customer_type as "customer_type: CustomerType",
                industry_classification, business_size as "business_size: BusinessSize",
                parent_customer_id, corporate_group_id, customer_hierarchy_level,
                consolidation_group, lifecycle_stage as "lifecycle_stage: CustomerLifecycleStage",
                status as "status: EntityStatus", credit_status as "credit_status: CreditStatus",
                primary_address_id, billing_address_id, shipping_address_ids,
                primary_contact_id, tax_jurisdictions, tax_numbers,
                regulatory_classifications, compliance_status as "compliance_status: ComplianceStatus",
                kyc_status as "kyc_status: KycStatus", aml_risk_rating as "aml_risk_rating: RiskRating",
                currency_code, credit_limit, payment_terms, tax_exempt,
                price_group_id, discount_group_id, sales_representative_id,
                account_manager_id, customer_segments, acquisition_channel as "acquisition_channel: AcquisitionChannel",
                customer_lifetime_value, churn_probability,
                master_data_source as "master_data_source: DataSource",
                external_id, sync_status as "sync_status: SyncStatus",
                last_sync_timestamp, sync_errors,
                created_by, created_at, modified_by, modified_at, version
            FROM customers
            WHERE tenant_id = $1 AND corporate_group_id = $2 AND status != 'deleted'
            ORDER BY customer_hierarchy_level, legal_name
            "#,
            self.tenant_context.tenant_id.0,
            group_id
        )
        .fetch_all(&self.pool)
        .await?;

        let mut customers = Vec::new();
        for row in rows {
            customers.push(self.build_customer_from_row(&row, false).await?);
        }

        Ok(customers)
    }

    async fn is_customer_number_available(&self, customer_number: &str) -> Result<bool> {
        let count = sqlx::query_scalar!(
            "SELECT COUNT(*) FROM customers WHERE tenant_id = $1 AND customer_number = $2",
            self.tenant_context.tenant_id.0,
            customer_number
        )
        .fetch_one(&self.pool)
        .await?;

        Ok(count.unwrap_or(0) == 0)
    }

    async fn generate_customer_number(&self, customer_type: &CustomerType) -> Result<String> {
        // Implementation for generating customer numbers based on type and sequence
        let prefix = match customer_type {
            CustomerType::B2b => "C",
            CustomerType::B2c => "R", // Retail
            CustomerType::B2g => "G", // Government
            CustomerType::Internal => "I",
            CustomerType::Reseller => "P", // Partner
            CustomerType::Distributor => "D",
            CustomerType::EndUser => "E",
            CustomerType::Prospect => "PR",
        };

        // Get next sequence number for this tenant and type
        let next_seq = sqlx::query_scalar!(
            r#"
            SELECT COALESCE(MAX(
                CASE
                    WHEN customer_number ~ '^[A-Z]+[0-9]+$'
                    THEN (regexp_replace(customer_number, '^[A-Z]+', ''))::INTEGER
                    ELSE 0
                END
            ), 0) + 1
            FROM customers
            WHERE tenant_id = $1 AND customer_number LIKE $2
            "#,
            self.tenant_context.tenant_id.0,
            format!("{}%", prefix)
        )
        .fetch_one(&self.pool)
        .await?;

        Ok(format!("{}{:06}", prefix, next_seq.unwrap_or(1)))
    }

    async fn update_performance_metrics(&self, customer_id: Uuid, metrics: &CustomerPerformanceMetrics) -> Result<()> {
        sqlx::query!(
            r#"
            INSERT INTO customer_performance_metrics (
                tenant_id, customer_id, total_revenue, average_order_value,
                total_orders, last_order_date, relationship_duration_days,
                satisfaction_score, net_promoter_score, last_contact_date,
                contact_frequency, response_rate, days_sales_outstanding,
                payment_reliability_score, support_ticket_count,
                last_calculated, created_by, modified_by
            ) VALUES (
                $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
                $11, $12, $13, $14, $15, $16, $17, $18
            )
            ON CONFLICT (tenant_id, customer_id)
            DO UPDATE SET
                total_revenue = EXCLUDED.total_revenue,
                average_order_value = EXCLUDED.average_order_value,
                total_orders = EXCLUDED.total_orders,
                last_order_date = EXCLUDED.last_order_date,
                relationship_duration_days = EXCLUDED.relationship_duration_days,
                satisfaction_score = EXCLUDED.satisfaction_score,
                net_promoter_score = EXCLUDED.net_promoter_score,
                last_contact_date = EXCLUDED.last_contact_date,
                contact_frequency = EXCLUDED.contact_frequency,
                response_rate = EXCLUDED.response_rate,
                days_sales_outstanding = EXCLUDED.days_sales_outstanding,
                payment_reliability_score = EXCLUDED.payment_reliability_score,
                support_ticket_count = EXCLUDED.support_ticket_count,
                last_calculated = EXCLUDED.last_calculated,
                modified_by = EXCLUDED.modified_by,
                modified_at = now()
            "#,
            self.tenant_context.tenant_id.0,
            customer_id,
            metrics.total_revenue,
            metrics.average_order_value,
            metrics.total_orders,
            metrics.last_order_date,
            metrics.relationship_duration_days,
            metrics.satisfaction_score,
            metrics.net_promoter_score,
            metrics.last_contact_date,
            metrics.contact_frequency,
            metrics.response_rate,
            metrics.days_sales_outstanding,
            metrics.payment_reliability_score,
            metrics.support_ticket_count,
            metrics.last_calculated,
            self.tenant_context.user_id(),
            self.tenant_context.user_id()
        )
        .execute(&self.pool)
        .await?;

        Ok(())
    }

    async fn update_behavioral_data(&self, customer_id: Uuid, data: &CustomerBehavioralData) -> Result<()> {
        sqlx::query!(
            r#"
            INSERT INTO customer_behavioral_data (
                tenant_id, customer_id, preferred_purchase_channels,
                seasonal_purchase_patterns, product_category_preferences,
                preferred_contact_times, channel_engagement_rates,
                website_engagement_score, mobile_app_usage, social_media_sentiment,
                propensity_to_buy, upsell_probability, cross_sell_probability,
                last_updated, created_by, modified_by
            ) VALUES (
                $1, $2, $3, $4, $5, $6, $7, $8, $9, $10,
                $11, $12, $13, $14, $15, $16
            )
            ON CONFLICT (tenant_id, customer_id)
            DO UPDATE SET
                preferred_purchase_channels = EXCLUDED.preferred_purchase_channels,
                seasonal_purchase_patterns = EXCLUDED.seasonal_purchase_patterns,
                product_category_preferences = EXCLUDED.product_category_preferences,
                preferred_contact_times = EXCLUDED.preferred_contact_times,
                channel_engagement_rates = EXCLUDED.channel_engagement_rates,
                website_engagement_score = EXCLUDED.website_engagement_score,
                mobile_app_usage = EXCLUDED.mobile_app_usage,
                social_media_sentiment = EXCLUDED.social_media_sentiment,
                propensity_to_buy = EXCLUDED.propensity_to_buy,
                upsell_probability = EXCLUDED.upsell_probability,
                cross_sell_probability = EXCLUDED.cross_sell_probability,
                last_updated = EXCLUDED.last_updated,
                modified_by = EXCLUDED.modified_by,
                modified_at = now()
            "#,
            self.tenant_context.tenant_id.0,
            customer_id,
            serde_json::to_value(&data.preferred_purchase_channels)?,
            serde_json::to_value(&data.seasonal_purchase_patterns)?,
            serde_json::to_value(&data.product_category_preferences)?,
            serde_json::to_value(&data.preferred_contact_times)?,
            serde_json::to_value(&data.channel_engagement_rates)?,
            data.website_engagement_score,
            data.mobile_app_usage,
            data.social_media_sentiment,
            data.propensity_to_buy,
            data.upsell_probability,
            data.cross_sell_probability,
            data.last_updated,
            self.tenant_context.user_id(),
            self.tenant_context.user_id()
        )
        .execute(&self.pool)
        .await?;

        Ok(())
    }

    async fn get_customer_addresses(&self, customer_id: Uuid) -> Result<Vec<Address>> {
        let rows = sqlx::query!(
            r#"
            SELECT
                id, address_type as "address_type: AddressType",
                street_line_1, street_line_2, city, state_province,
                postal_code, country_code, latitude, longitude,
                coordinate_accuracy, what3words_address, plus_code, timezone,
                is_primary, is_active,
                created_by, created_at, modified_by, modified_at, version
            FROM addresses
            WHERE tenant_id = $1 AND entity_type = 'customer' AND entity_id = $2 AND is_active = true
            ORDER BY is_primary DESC, address_type, created_at
            "#,
            self.tenant_context.tenant_id.0,
            customer_id
        )
        .fetch_all(&self.pool)
        .await?;

        let mut addresses = Vec::new();
        for row in rows {
            addresses.push(Address {
                id: row.id,
                entity_type: "customer".to_string(),
                entity_id: customer_id,
                address_type: row.address_type,
                street_line_1: row.street_line_1,
                street_line_2: row.street_line_2,
                city: row.city,
                state_province: row.state_province,
                postal_code: row.postal_code,
                country_code: row.country_code,
                coordinates: if let (Some(lat), Some(lng)) = (row.latitude, row.longitude) {
                    Some(GeoCoordinates {
                        latitude: lat.to_f64().unwrap(),
                        longitude: lng.to_f64().unwrap(),
                        accuracy: row.coordinate_accuracy,
                    })
                } else {
                    None
                },
                is_primary: row.is_primary,
                is_active: row.is_active,
                audit: AuditFields {
                    created_by: row.created_by,
                    created_at: row.created_at,
                    modified_by: row.modified_by,
                    modified_at: row.modified_at,
                    version: row.version,
                    is_deleted: false,
                    deleted_at: None,
                    deleted_by: None,
                },
            });
        }

        Ok(addresses)
    }

    async fn get_customer_contacts(&self, customer_id: Uuid) -> Result<Vec<ContactInfo>> {
        let rows = sqlx::query!(
            r#"
            SELECT
                id, contact_type as "contact_type: ContactType",
                first_name, last_name, title, department,
                email, phone, mobile, fax, linkedin_profile,
                preferred_language, communication_preferences,
                is_primary, is_active,
                created_by, created_at, modified_by, modified_at, version
            FROM contacts
            WHERE tenant_id = $1 AND entity_type = 'customer' AND entity_id = $2 AND is_active = true
            ORDER BY is_primary DESC, contact_type, last_name, first_name
            "#,
            self.tenant_context.tenant_id.0,
            customer_id
        )
        .fetch_all(&self.pool)
        .await?;

        let mut contacts = Vec::new();
        for row in rows {
            contacts.push(ContactInfo {
                id: row.id,
                entity_type: "customer".to_string(),
                entity_id: customer_id,
                contact_type: row.contact_type,
                first_name: row.first_name,
                last_name: row.last_name,
                title: row.title,
                department: row.department,
                email: row.email,
                phone: row.phone,
                mobile: row.mobile,
                fax: row.fax,
                preferred_language: row.preferred_language,
                communication_preferences: serde_json::from_value(row.communication_preferences)
                    .unwrap_or_default(),
                is_primary: row.is_primary,
                is_active: row.is_active,
                audit: AuditFields {
                    created_by: row.created_by,
                    created_at: row.created_at,
                    modified_by: row.modified_by,
                    modified_at: row.modified_at,
                    version: row.version,
                    is_deleted: false,
                    deleted_at: None,
                    deleted_by: None,
                },
            });
        }

        Ok(contacts)
    }

    async fn add_customer_address(&self, customer_id: Uuid, address: &CreateAddressRequest, created_by: Uuid) -> Result<Address> {
        let mut tx = self.pool.begin().await?;
        let address_id = self.create_address_internal(&mut tx, customer_id, "customer", address, created_by).await?;
        tx.commit().await?;

        // Fetch and return the created address
        let row = sqlx::query!(
            r#"
            SELECT
                id, address_type as "address_type: AddressType",
                street_line_1, street_line_2, city, state_province,
                postal_code, country_code, latitude, longitude,
                coordinate_accuracy, what3words_address, plus_code, timezone,
                is_primary, is_active,
                created_by, created_at, modified_by, modified_at, version
            FROM addresses
            WHERE tenant_id = $1 AND id = $2
            "#,
            self.tenant_context.tenant_id.0,
            address_id
        )
        .fetch_one(&self.pool)
        .await?;

        Ok(Address {
            id: row.id,
            entity_type: "customer".to_string(),
            entity_id: Uuid::new_v4(), // This should be set from context
            address_type: row.address_type,
            street_line_1: row.street_line_1,
            street_line_2: row.street_line_2,
            city: row.city,
            state_province: row.state_province,
            postal_code: row.postal_code,
            country_code: row.country_code,
            coordinates: if let (Some(lat), Some(lng)) = (row.latitude, row.longitude) {
                Some(GeoCoordinates {
                    latitude: lat.to_f64().unwrap(),
                    longitude: lng.to_f64().unwrap(),
                    accuracy: row.coordinate_accuracy,
                })
            } else {
                None
            },
            is_primary: row.is_primary,
            is_active: row.is_active,
            audit: AuditFields {
                created_by: row.created_by,
                created_at: row.created_at,
                modified_by: row.modified_by,
                modified_at: row.modified_at,
                version: row.version,
                is_deleted: false,
                deleted_at: None,
                deleted_by: None,
            },
        })
    }

    async fn add_customer_contact(&self, customer_id: Uuid, contact: &CreateContactRequest, created_by: Uuid) -> Result<ContactInfo> {
        let mut tx = self.pool.begin().await?;
        let contact_id = self.create_contact_internal(&mut tx, customer_id, "customer", contact, created_by).await?;
        tx.commit().await?;

        // Fetch and return the created contact
        let row = sqlx::query!(
            r#"
            SELECT
                id, contact_type as "contact_type: ContactType",
                first_name, last_name, title, department,
                email, phone, mobile, fax, linkedin_profile,
                preferred_language, communication_preferences,
                is_primary, is_active,
                created_by, created_at, modified_by, modified_at, version
            FROM contacts
            WHERE tenant_id = $1 AND id = $2
            "#,
            self.tenant_context.tenant_id.0,
            contact_id
        )
        .fetch_one(&self.pool)
        .await?;

        Ok(ContactInfo {
            id: row.id,
            entity_type: "customer".to_string(),
            entity_id: Uuid::new_v4(), // This should be set from context
            contact_type: row.contact_type,
            first_name: row.first_name,
            last_name: row.last_name,
            title: row.title,
            department: row.department,
            email: row.email,
            phone: row.phone,
            mobile: row.mobile,
            fax: row.fax,
            preferred_language: row.preferred_language,
            communication_preferences: serde_json::from_value(row.communication_preferences)
                .unwrap_or_default(),
            is_primary: row.is_primary,
            is_active: row.is_active,
            audit: AuditFields {
                created_by: row.created_by,
                created_at: row.created_at,
                modified_by: row.modified_by,
                modified_at: row.modified_at,
                version: row.version,
                is_deleted: false,
                deleted_at: None,
                deleted_by: None,
            },
        })
    }

    async fn update_address(&self, address_id: Uuid, address: &Address, modified_by: Uuid) -> Result<Address> {
        let rows_affected = sqlx::query!(
            r#"
            UPDATE addresses SET
                address_type = $1::address_type,
                street_line_1 = $2,
                street_line_2 = $3,
                city = $4,
                state_province = $5,
                postal_code = $6,
                country_code = $7,
                latitude = $8,
                longitude = $9,
                coordinate_accuracy = $10,
                is_primary = $11,
                modified_by = $12,
                modified_at = now(),
                version = version + 1
            WHERE tenant_id = $13 AND id = $14 AND version = $15
            "#,
            address.address_type,
            address.street_line_1,
            address.street_line_2,
            address.city,
            address.state_province,
            address.postal_code,
            address.country_code,
            address.coordinates.as_ref().map(|c| rust_decimal::Decimal::from_f64_retain(c.latitude)),
            address.coordinates.as_ref().map(|c| rust_decimal::Decimal::from_f64_retain(c.longitude)),
            address.coordinates.as_ref().and_then(|c| c.accuracy),
            address.is_primary,
            modified_by,
            self.tenant_context.tenant_id.0,
            address_id,
            address.audit.version
        )
        .execute(&self.pool)
        .await?
        .rows_affected();

        if rows_affected == 0 {
            return Err(MasterDataError::CustomerNotFound { id: address_id.to_string() });
        }

        // Fetch and return the updated address
        let row = sqlx::query!(
            r#"
            SELECT
                id, address_type as "address_type: AddressType",
                street_line_1, street_line_2, city, state_province,
                postal_code, country_code, latitude, longitude,
                coordinate_accuracy, what3words_address, plus_code, timezone,
                is_primary, is_active,
                created_by, created_at, modified_by, modified_at, version
            FROM addresses
            WHERE tenant_id = $1 AND id = $2
            "#,
            self.tenant_context.tenant_id.0,
            address_id
        )
        .fetch_one(&self.pool)
        .await?;

        Ok(Address {
            id: row.id,
            entity_type: "customer".to_string(),
            entity_id: Uuid::new_v4(), // This should be set from context
            address_type: row.address_type,
            street_line_1: row.street_line_1,
            street_line_2: row.street_line_2,
            city: row.city,
            state_province: row.state_province,
            postal_code: row.postal_code,
            country_code: row.country_code,
            coordinates: if let (Some(lat), Some(lng)) = (row.latitude, row.longitude) {
                Some(GeoCoordinates {
                    latitude: lat.to_f64().unwrap(),
                    longitude: lng.to_f64().unwrap(),
                    accuracy: row.coordinate_accuracy,
                })
            } else {
                None
            },
            is_primary: row.is_primary,
            is_active: row.is_active,
            audit: AuditFields {
                created_by: row.created_by,
                created_at: row.created_at,
                modified_by: row.modified_by,
                modified_at: row.modified_at,
                version: row.version,
                is_deleted: false,
                deleted_at: None,
                deleted_by: None,
            },
        })
    }

    async fn update_contact(&self, contact_id: Uuid, contact: &ContactInfo, modified_by: Uuid) -> Result<ContactInfo> {
        let rows_affected = sqlx::query!(
            r#"
            UPDATE contacts SET
                contact_type = $1::contact_type,
                first_name = $2,
                last_name = $3,
                title = $4,
                department = $5,
                email = $6,
                phone = $7,
                mobile = $8,
                fax = $9,
                preferred_language = $10,
                communication_preferences = $11,
                is_primary = $12,
                modified_by = $13,
                modified_at = now(),
                version = version + 1
            WHERE tenant_id = $14 AND id = $15 AND version = $16
            "#,
            contact.contact_type,
            contact.first_name,
            contact.last_name,
            contact.title,
            contact.department,
            contact.email,
            contact.phone,
            contact.mobile,
            contact.fax,
            contact.preferred_language,
            sqlx::types::Json(&contact.communication_preferences),
            contact.is_primary,
            modified_by,
            self.tenant_context.tenant_id.0,
            contact_id,
            contact.audit.version
        )
        .execute(&self.pool)
        .await?
        .rows_affected();

        if rows_affected == 0 {
            return Err(MasterDataError::CustomerNotFound { id: contact_id.to_string() });
        }

        // Fetch and return the updated contact
        let row = sqlx::query!(
            r#"
            SELECT
                id, contact_type as "contact_type: ContactType",
                first_name, last_name, title, department,
                email, phone, mobile, fax, linkedin_profile,
                preferred_language, communication_preferences,
                is_primary, is_active,
                created_by, created_at, modified_by, modified_at, version
            FROM contacts
            WHERE tenant_id = $1 AND id = $2
            "#,
            self.tenant_context.tenant_id.0,
            contact_id
        )
        .fetch_one(&self.pool)
        .await?;

        Ok(ContactInfo {
            id: row.id,
            entity_type: "customer".to_string(),
            entity_id: Uuid::new_v4(), // This should be set from context
            contact_type: row.contact_type,
            first_name: row.first_name,
            last_name: row.last_name,
            title: row.title,
            department: row.department,
            email: row.email,
            phone: row.phone,
            mobile: row.mobile,
            fax: row.fax,
            preferred_language: row.preferred_language,
            communication_preferences: serde_json::from_value(row.communication_preferences)
                .unwrap_or_default(),
            is_primary: row.is_primary,
            is_active: row.is_active,
            audit: AuditFields {
                created_by: row.created_by,
                created_at: row.created_at,
                modified_by: row.modified_by,
                modified_at: row.modified_at,
                version: row.version,
                is_deleted: false,
                deleted_at: None,
                deleted_by: None,
            },
        })
    }

    async fn delete_address(&self, address_id: Uuid) -> Result<()> {
        let rows_affected = sqlx::query!(
            "UPDATE addresses SET is_active = false WHERE tenant_id = $1 AND id = $2",
            self.tenant_context.tenant_id.0,
            address_id
        )
        .execute(&self.pool)
        .await?
        .rows_affected();

        if rows_affected == 0 {
            return Err(MasterDataError::CustomerNotFound { id: address_id.to_string() });
        }

        Ok(())
    }

    async fn delete_contact(&self, contact_id: Uuid) -> Result<()> {
        let rows_affected = sqlx::query!(
            "UPDATE contacts SET is_active = false WHERE tenant_id = $1 AND id = $2",
            self.tenant_context.tenant_id.0,
            contact_id
        )
        .execute(&self.pool)
        .await?
        .rows_affected();

        if rows_affected == 0 {
            return Err(MasterDataError::CustomerNotFound { id: contact_id.to_string() });
        }

        Ok(())
    }
}

// Internal helper methods for PostgresCustomerRepository
impl PostgresCustomerRepository {
    /// Helper method to bind search parameters to a query
    fn bind_search_parameters<'a>(
        &self,
        mut query: sqlx::query::Query<'a, Postgres, sqlx::postgres::PgArguments>,
        criteria: &'a CustomerSearchCriteria,
        include_limit_offset: bool,
    ) -> Result<sqlx::query::Query<'a, Postgres, sqlx::postgres::PgArguments>> {
        // Text search
        if let Some(ref search_term) = criteria.search_term {
            if !search_term.trim().is_empty() {
                query = query.bind(search_term);
            }
        }

        // Customer numbers
        if let Some(ref customer_numbers) = criteria.customer_numbers {
            if !customer_numbers.is_empty() {
                query = query.bind(customer_numbers);
            }
        }

        // Customer types
        if let Some(ref customer_types) = criteria.customer_types {
            if !customer_types.is_empty() {
                let types: Vec<String> = customer_types.iter().map(|t| format!("{:?}", t).to_lowercase()).collect();
                query = query.bind(types);
            }
        }

        // Statuses
        if let Some(ref statuses) = criteria.statuses {
            if !statuses.is_empty() {
                let status_strings: Vec<String> = statuses.iter().map(|s| format!("{:?}", s).to_lowercase()).collect();
                query = query.bind(status_strings);
            }
        }

        // Lifecycle stages
        if let Some(ref lifecycle_stages) = criteria.lifecycle_stages {
            if !lifecycle_stages.is_empty() {
                let stage_strings: Vec<String> = lifecycle_stages.iter().map(|s| format!("{:?}", s).to_lowercase()).collect();
                query = query.bind(stage_strings);
            }
        }

        // Hierarchy filters
        if let Some(parent_id) = criteria.parent_customer_id {
            query = query.bind(parent_id);
        }

        if let Some(group_id) = criteria.corporate_group_id {
            query = query.bind(group_id);
        }

        if let Some(level) = criteria.hierarchy_level {
            query = query.bind(level as i16);
        }

        // Geographic filters
        if let Some(ref country_codes) = criteria.country_codes {
            if !country_codes.is_empty() {
                query = query.bind(country_codes);
            }
        }

        if let Some(ref cities) = criteria.cities {
            if !cities.is_empty() {
                query = query.bind(cities);
            }
        }

        // Commercial filters
        if let Some(ref sales_rep_ids) = criteria.sales_representative_ids {
            if !sales_rep_ids.is_empty() {
                query = query.bind(sales_rep_ids);
            }
        }

        if let Some(ref account_mgr_ids) = criteria.account_manager_ids {
            if !account_mgr_ids.is_empty() {
                query = query.bind(account_mgr_ids);
            }
        }

        if let Some(ref credit_statuses) = criteria.credit_statuses {
            if !credit_statuses.is_empty() {
                let credit_strings: Vec<String> = credit_statuses.iter().map(|s| format!("{:?}", s).to_lowercase()).collect();
                query = query.bind(credit_strings);
            }
        }

        // Financial filters
        if let Some(min_credit) = criteria.min_credit_limit {
            query = query.bind(min_credit);
        }

        if let Some(max_credit) = criteria.max_credit_limit {
            query = query.bind(max_credit);
        }

        if let Some(min_clv) = criteria.min_customer_lifetime_value {
            query = query.bind(min_clv);
        }

        if let Some(max_clv) = criteria.max_customer_lifetime_value {
            query = query.bind(max_clv);
        }

        // Date filters
        if let Some(created_after) = criteria.created_after {
            query = query.bind(created_after);
        }

        if let Some(created_before) = criteria.created_before {
            query = query.bind(created_before);
        }

        if let Some(modified_after) = criteria.modified_after {
            query = query.bind(modified_after);
        }

        if let Some(modified_before) = criteria.modified_before {
            query = query.bind(modified_before);
        }

        // Analytics filters
        if let Some(min_churn) = criteria.min_churn_probability {
            query = query.bind(min_churn);
        }

        if let Some(max_churn) = criteria.max_churn_probability {
            query = query.bind(max_churn);
        }

        if let Some(ref risk_ratings) = criteria.risk_ratings {
            if !risk_ratings.is_empty() {
                let risk_strings: Vec<String> = risk_ratings.iter().map(|r| format!("{:?}", r).to_lowercase()).collect();
                query = query.bind(risk_strings);
            }
        }

        Ok(query)
    }
    async fn create_address_internal(
        &self,
        tx: &mut sqlx::Transaction<'_, Postgres>,
        entity_id: Uuid,
        entity_type: &str,
        address: &CreateAddressRequest,
        created_by: Uuid,
    ) -> Result<Uuid> {
        let address_id = Uuid::new_v4();
        let now = Utc::now();

        sqlx::query!(
            r#"
            INSERT INTO addresses (
                id, tenant_id, entity_type, entity_id, address_type,
                street_line_1, street_line_2, city, state_province,
                postal_code, country_code, latitude, longitude,
                coordinate_accuracy, is_primary, is_active,
                created_by, created_at, modified_by, modified_at
            ) VALUES (
                $1, $2, $3, $4, $5::address_type, $6, $7, $8, $9, $10,
                $11, $12, $13, $14, $15, $16, $17, $18, $19, $20
            )
            "#,
            address_id,
            self.tenant_context.tenant_id.0,
            entity_type,
            entity_id,
            address.address_type,
            address.street_line_1,
            address.street_line_2,
            address.city,
            address.state_province,
            address.postal_code,
            address.country_code,
            address.coordinates.as_ref().map(|c| rust_decimal::Decimal::try_from(c.latitude).unwrap_or_default()),
            address.coordinates.as_ref().map(|c| rust_decimal::Decimal::try_from(c.longitude).unwrap_or_default()),
            address.coordinates.as_ref().and_then(|c| c.accuracy),
            address.is_primary.unwrap_or(false),
            true,
            created_by,
            now,
            created_by,
            now
        )
        .execute(&mut **tx)
        .await?;

        Ok(address_id)
    }

    async fn create_contact_internal(
        &self,
        tx: &mut sqlx::Transaction<'_, Postgres>,
        entity_id: Uuid,
        entity_type: &str,
        contact: &CreateContactRequest,
        created_by: Uuid,
    ) -> Result<Uuid> {
        let contact_id = Uuid::new_v4();
        let now = Utc::now();

        sqlx::query!(
            r#"
            INSERT INTO contacts (
                id, tenant_id, entity_type, entity_id, contact_type,
                first_name, last_name, title, department,
                email, phone, mobile, fax,
                preferred_language, communication_preferences,
                is_primary, is_active,
                created_by, created_at, modified_by, modified_at
            ) VALUES (
                $1, $2, $3, $4, $5::contact_type, $6, $7, $8, $9, $10,
                $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21
            )
            "#,
            contact_id,
            self.tenant_context.tenant_id.0,
            entity_type,
            entity_id,
            contact.contact_type,
            contact.first_name,
            contact.last_name,
            contact.title,
            contact.department,
            contact.email,
            contact.phone,
            contact.mobile,
            None::<String>, // fax
            contact.preferred_language,
            serde_json::to_value(contact.communication_preferences.as_ref().unwrap_or(&CommunicationPreferences::default()))?,
            contact.is_primary.unwrap_or(false),
            true,
            created_by,
            now,
            created_by,
            now
        )
        .execute(&mut **tx)
        .await?;

        Ok(contact_id)
    }
}